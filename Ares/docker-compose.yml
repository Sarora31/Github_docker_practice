version: '3.6'

services:
 #where we define our containers (apps).

  backend:
    build: backend #Docker will go inside the backend/ folder & It will look for a Dockerfile there & Then build the backend image
    hostname: backend-host #This sets the internal name of the container.
    volumes:
      - ./backend:/app     #Your local folder ./backend is connected to /app inside the container & if if we change code locally ‚Üí container updates automatically.Very useful for development.
    ports:
      - "8000:8000"  #Your backend runs on port 8000 inside container
    networks:
      - ares-network  #This connects backend to a custom Docker network so it can talk to frontend.

  frontend:
    build: frontend
    hostname: frontend-host
    volumes:
      - ./frontend:/app
    environment:
      - BACKEND_URL=http://backend-host:8000/api  #Telling fronted ‚ÄúWhen calling backend, use this URL & "backend host" here not local since inside Docker, containers talk to each other using service names.
    ports:
      - "3000:3000"
    depends_on:
      - backend   #Start backend first then start frontend & remember:It does NOT wait until backend is fully ready.It only ensures start order.
    networks:
      - ares-network

networks:
  ares-network: {} #This creates a private Docker network called:"ares-network" & Both frontend and backend are connected to it.



  # Docker will:
#
# 1Ô∏è‚É£ Build backend image
#    Docker reads the backend Dockerfile, installs all required dependencies,
#    copies your application code, sets environment variables, and prepares
#    everything needed to run your backend service.
#
# 2Ô∏è‚É£ Build frontend image
#    Docker reads the frontend Dockerfile, installs Node modules or other
#    frontend dependencies, builds the production-ready static files (if needed),
#    and prepares the frontend application to run inside its own container.
#
# 3Ô∏è‚É£ Create a network
#    Docker creates a private bridge network so both containers can communicate
#    securely using container names instead of localhost. This allows internal
#    service-to-service communication without exposing everything publicly.
#
# 4Ô∏è‚É£ Start backend on port 8000
#    Docker runs the backend container and maps container port 8000 to your
#    machine‚Äôs port 8000. The backend service (Flask, Django, Express, etc.)
#    starts listening for API requests.
#
# 5Ô∏è‚É£ Start frontend on port 3000
#    Docker runs the frontend container and maps container port 3000 to your
#    machine‚Äôs port 3000. This is where users access the UI in their browser.
#
# 6Ô∏è‚É£ Connect both so they can talk
#    The frontend container makes API requests to the backend container using
#    the Docker network (e.g., http://backend:8000). Because both are on the
#    same network, they can communicate directly and reliably.
#
#
# üß† Simple Real-World Analogy
#
# Think of it like running a restaurant:
#
# Backend = Kitchen üç≥
#    This is where the real work happens. Orders are processed, food is prepared,
#    and the final output (API response) is created.
#
# Frontend = Waiter üßë‚Äçüç≥
#    The waiter takes orders from customers (browser requests), sends them to
#    the kitchen (backend), and delivers the finished dishes (responses) back.
#
# Network = Hallway between them
#    The hallway connects the waiter and the kitchen. They don‚Äôt need to shout
#    outside the restaurant; they communicate internally through this path.
#
# Ports = Restaurant door for customers
#    Customers enter through the main door (localhost:3000).
#    They don‚Äôt see the kitchen directly; they interact with the waiter.
#
# Full Flow:
#    Customer ‚Üí localhost:3000 (Frontend / Waiter)
#    Waiter ‚Üí Sends order through hallway (Docker Network)
#    Kitchen ‚Üí Prepares food (Backend logic on port 8000)
#    Kitchen ‚Üí Sends food back through hallway
#    Waiter ‚Üí Serves customer in browser
#
# Everything runs in isolated containers, but Docker orchestrates them
# so they behave like one complete application system.